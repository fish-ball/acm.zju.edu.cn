// 后来补上，当时是裸奔的，居然有这种水平我现在自己都震惊
// 其实这只是一个 DP，经典的最长上升子序列，n^2 就可以过
// 能硬想出来，当时真不简单


假设输入的是坐标(x,y)
建立一个结构{index,x,y,prev,count}
先将所有档案按x的升序排列
注意index是原来的序号，输出时用
prev是这一个链结点的前一个结点的序号(排序后),初值为-1
count是该节点的子节点数目(包含其本身)，初值为1

例如output case 1:
开始:

index	x	y	prev	count
1	340 	500	-1	1
2	220 	470	-1	1
3	100 	300	-1	1
4	880 	943	-1	1
5	525 	556	-1	1
6	612 	776	-1	1

然后，按x排序：

index	x	y	prev	count
3	100 	300	-1	1
2	220 	470	-1	1
1	340 	500	-1	1
5	525 	556	-1	1
6	612 	776	-1	1
4	880 	943	-1	1

然后从上往下，检查每个节点i：
假如在节点i前面有节点j，它满足j->y 小于 i->x
并且，在所有满足这样条件的j里面，其中一个的count最大
那么，就令节点i的prev指向它，并且i->count = j->count + 1
过程如下图所示：
Step 1:
index	x	y	prev	count
3	100 	300	-1	1	<---i
2	220 	470	-1	1
1	340 	500	-1	1
5	525 	556	-1	1
6	612 	776	-1	1
4	880 	943	-1	1

Step 2:
index	x	y	prev	count
3	100 	300	-1	1
2	220 	470	-1	1	<---i
1	340 	500	-1	1
5	525 	556	-1	1
6	612 	776	-1	1
4	880 	943	-1	1

Step 3:
index	x	y	prev	count
3	100 	300	-1	1	<---j
2	220 	470	-1	1
1	340 	500	0	2	<---i
5	525 	556	-1	1
6	612 	776	-1	1
4	880 	943	-1	1

Step 4:
index	x	y	prev	count
3	100 	300	-1	1
2	220 	470	-1	1
1	340 	500	0	2	<---j
5	525 	556	2	3	<---i
6	612 	776	-1	1
4	880 	943	-1	1

Step 5:
index	x	y	prev	count
3	100 	300	-1	1
2	220 	470	-1	1
1	340 	500	0	2
5	525 	556	2	3	<---j
6	612 	776	3	4	<---i
4	880 	943	-1	1

Step 6:
index	x	y	prev	count
3	100 	300	-1	1
2	220 	470	-1	1
1	340 	500	0	2
5	525 	556	2	4
6	612 	776	3	4	<---j
4	880 	943	4	5	<---i

这样就处理完毕了。

然后找出count最大的一个，它是链尾，应该输出的值为index
然后根据prev找到他的上一个，如此类推

此处的顺序应该是：
5->4->3->2->0
它们的index应该是：
4->6->5->1->3

输出应该倒过来：
3 1 5 6 4

