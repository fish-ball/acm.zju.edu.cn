// 1802934 2009-03-25 09:42:47 Accepted  3182 C++ 0 184 呆滞的慢板 

// 其实这道题的递推关系与汉诺塔非常相似：
// 要求将所有圆盘串起来，第一个圆盘可以随意取放。
// 如果第 i 个在串上，且 1..i-1 都不在串上，那么第 i + 1 个可随意取放。
// 问最少多少步可以将全部圆盘串起来。
// 假设 f(n) 是在 1..n 全为空的时候将 n 盘放到串上的代价。
// 不难得到递推式: f(n) = f(n-1) + 1 + f(n-1)。 
// 因为操作总是先将第 n-1 个圆盘单独放上去，需要 f(n-1) 步。
// 这时候就可以放上第 n 个圆盘了，再加一步。
// 然后将第 n-1 个拿走，同样也需要 f(n-1) 步。
// 根据初始条件 f(1) = 1，可得通项公式 f(n) = 2^n - 1。
// 然后最优的策略就是每次操作放好最大号的圆盘：
// 例如 n=9，我先放好 8,9 再放 6,7，直到最后剩下 1 个，再单放一个。
// 为什么要一次放两个呢？因为后面的放好了前面的就没有关系了， 
// 而放好第 n 和第 n-1 个，我只需放好第 n-1 个，然后再放上第 n 个就行了。
// 最后，结果对 N 逆推一下就可以了。 

#include <iostream>
using namespace std;

int main() {
    int T, N;
    for(cin >> T; T--;) {
        cin >> N;
        int ans = 0;
        while(N > 1) {
            ans += 1 << N - 1;
            N -= 2;
        }
        if(N == 1) ans += 1;
        cout << ans << endl;
    }
}
